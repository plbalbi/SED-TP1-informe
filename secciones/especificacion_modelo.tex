% !TeX root = ../main.tex

% Document-wide defines
\newcommand{\Reals}{{\rm I\!R}}

% DEVS model definition helpers
\newcommand{\deltaInt}[1]{
    \begin{algorithm}[H]
        \caption{$\delta_{int} (s)$}
        \begin{algorithmic}
        #1
        \end{algorithmic}
    \end{algorithm}
}
\newcommand{\deltaExt}[1]{
    \begin{algorithm}[H]
        \caption{$\delta_{ext} (s,e,x)$}
        \begin{algorithmic}
        #1
        \end{algorithmic}
    \end{algorithm}
}
\newcommand{\lambdaOut}[1]{
    \begin{algorithm}[H]
        \caption{$\lambda (s)$}
        \begin{algorithmic}
        #1
        \end{algorithmic}
    \end{algorithm}
}

\section{Especificación Formal}

\subsection{Modelos Atómicos}

\subsubsection{Panel solar y generador eólico}
Como fue descripto en el modelo conceptual (\ref{section:modeloConceptual}),
el modelo que representa al panel solar, y también al generador eólico son
simples. Ambos tendrán un puerto de entrada, el cual recibirá el valor de la
magnitud de clima que los afecta, siendo radiación en el caso del primero, y
la velocidad del viento para el segundo. Por otro lado, tendrán un puerto de
salida, por el cual notificarán a los modelos que tengan una conexión al
mismo, cual es la nueva cantidad de energía que están produciendo.

% TODO: Poner algo haciendo referencia a que DEVS puede manejar eventos (cambios en dichas magnitudes climáticas) a distintas frecuencias de ocurrencia. Leer en el Wainer como se explicaba esto.
% TODO: Poner las funciones de transición, y las funciones matemáticas con las cuales se calculará la potencia producida.

$Generador = <X,Y,S,\delta_{int}, \delta_{ext}, \lambda, ta>$

Definiendo cada elemento de la tupla DEVS como:

\begin{align*}
X &= \Reals_{\geq0} & Y &= \Reals_{\geq0} & S &= energiaProducida \in \Reals_{\geq 0} \\
\end{align*}

\deltaInt{
    \STATE passivate()
}

\deltaExt{
    \STATE $energiaProducida \leftarrow calcularPotenciaProducida(x.value) $
}

\lambdaOut{
    \STATE sendOutput(time, out, energiaProducida)
}

\subsubsection{Batería}
El modelo de la batería consta de tres puertos de entrada y dos de salida.

Tiene un puerto en el cual recibe los cambios en la cantidad de energía generada
por el generador eólico y otro en el cual recibe la generada por el panel solar.
En el tercer puerto recibe la cantidad de energía solicitada por el controlador.

Los puertos de salida son el del estado de la batería, que informa el estado actual
de la batería, que puede ser:

\begin{itemize}
    \item \emph{Vacía}: En este estado, la carga es 0, y se mantiene en él, hasta
        que llegue energía por alguno de los generadores.
    \item \emph{Cargando}: Posee carga, pero se encuentra por debajo del límite
        mínimo para enviar. En este estado, la batería no hace disponible la carga.
    \item \emph{Disponibe}: En este estado, la batería ya se encuentra disponible
        para enviar carga, pero aún no esta llena.
    \item \emph{Completa}: Ocurre cuando la carga alcanza la máxima capacidad. En este
        estado, la batería informa al controlador la cantidad de energía que se está
        produciendo en exceso, para que pueda entregarla a la red.
\end{itemize}

Hay que aclarar que la batería no pasa del estado \emph{Disponibe} al \emph{Cargando}
cuando se consume la carga y esta alcanza niveles por debajo del limite de envío, sino que
la batería continúa enviando hasta que pasa al estado \emph{Vacía}.

Así, el conjunto de variables que conforman de estado de la batería, es el siguiente:

\begin{itemize}
    \item \textbf{solarPanelPower:} Cantidad de energía enviada desde el panel solar.  Real mayor o igual a 0.
    \item \textbf{windTurbinePower:} Cantidad de energía enviada desde la turbina eolica.  Real mayor o igual a 0.
    \item \textbf{controllerDemand:} Cantidad de energía solicitada por el controlador. Real mayor o igual a 0.
    \item \textbf{charge:} Energía acumulada en la batería. Real mayor o igual a 0
    \item \textbf{lastChargeUpdate:} Tiempo en que se realizó la ultima actualización del estado de la carga.
    Variable de tipo VTime, mayor a 0
    \item \textbf{state:} Estado actual de la batería. Uno de los cuatro valores mensionados anteriormente.
\end{itemize}

Formalmente, $S \in \mathbb{R}_{\geq 0}^4 \times VTime_{\geq 0} \times \{Vacia, Cargando, Disponibe, Completa\}$ 

Para calcular el valor real de la carga que posee la batería en el tiempo actual $t$, 
tenemos que combinar todas estas variables de estado:

$$CargaReal = charge+(lastChargeUpdate - t) \times \Delta_{energia}$$

Donde $\Delta_{energia}$ es igual a la diferencia de la energía producida por los generadores y la enviada
por la batería.

Con cada cambio de alguna de estas variables, actualizamos el valor de \textbf{charge} para así
mantener la ecuación descripta anteriormente.

Esta misma formula se puede reescribir para calcular cuando sucederá el próximo cambio de la variable $state$:

$$ta = \frac{CargaEnProximoEstado - charge}{\Delta_{energia}}$$

En cuanto a las transiciones externas, en ellas tenemos que recalcular \textbf{charge} y el momento en que se
producirá el proximo cambio de estado.

\deltaExt{
    \STATE {charge $\leftarrow$ calculate\_current\_charge(s, e)}
    \IF {x.port = SOLAR\_PANEL}
        \STATE S' $\leftarrow$ $<$x.value, S.windTurbinePower, S.controllerDemand, charge, e, s.state$>$
    \ELSIF{x.port = EOLIC\_TURBINE}
        \STATE S' $\leftarrow$ $<$S.solarPanelPower, x.value, S.controllerDemand, charge, e, s.state$>$
    \ELSIF{x.port = REQUIRED\_ENERGY}
        \STATE S' $\leftarrow$ $<$S.solarPanelPower, S.windTurbinePower, x.value, charge, e, s.state$>$
    \ENDIF
    \STATE next\_change $\leftarrow$ calculate\_next\_event(S')
    \RETURN {S'}
}

Las transiciones internas, se corresponden a cambios en del estado.

\lambdaOut{
    \STATE {charge $\leftarrow$ calculate\_current\_charge(s, current\_time)}
    \STATE {(S', next\_change) $\leftarrow$ calculate\_next\_state(s, charge, current\_time)}
    \RETURN {S'}
}

\lambdaOut{
    \STATE {charge $\leftarrow$ calculate\_current\_charge(s, current\_time)}
    \STATE {(S', next\_change) $\leftarrow$ calculate\_next\_state(s, charge, current\_time)}
    \STATE {sendOutput(time, battery\_state\_port, S'.state)}
    \IF {S'.state = \emph{Completa}}
        \STATE {sendOutput(time, out, $\Delta_{energy}$(S'))}
    \ENDIF
}

Hay que mencionar que, si bien no se refleja en el pseudocódigo, también usamos las
transiciones internas para poder informar cambios en la cantidad de energía sobrante cuando
la batería se encuentra llena, ya que si bien no cambia el valor de la variable \textbf{state},
no podemos hacer uso de la función de output desde transiciones externas.

\subsubsection{Controlador}

El modelo del controlador consta de cinco puertos, tres de entrada y tres de salida.

Uno de los puertos de entrada es donde recibe las solicitudes de la carga, otro
es donde recibe el estado actual de la batería y el tercero es por donde la batería 
le avisa la cantidad de energía sobrante.

En cuanto a los puertos de salida, corresponden a los pedidos de energía a la red, los pedidos a la batería, y por último, la energía \textbf{vendida} a la red.

En cuanto al estado interno del controlador, el mismo debe almacenar los siguientes valores:

\begin{itemize}
    \item \textbf{batteryState:} Almacena el estado actual de la batería que tiene conectada,
    es necesario para determinar si podemos pedirle energía a la misma o no.
    \item \textbf{currentLoadDemand:} Cantidad de energía solicitada por la carga.
    \item \textbf{batteryDemand:} Cantidad de energía solicitada/vendida a la batería.
    \item \textbf{gridDemand:} Cantidad de energía solicitada a la red.
    \item \textbf{extraEnergy:} Cantidad de energía excedente siendo generada. 
\end{itemize}

Como el comportamiento del controlador se encuentra fuertemente relacionado con el de la batería, este se separó en dos estados posibles:
\begin{itemize}
    \item \textbf{AllGrid}: La totalidad de la energía solicitada es suplida por la red.
    \item \textbf{GridAndBattery}: Como la batería puede suplir energía, la carga solicitada es repartida entre esta y la red.
\end{itemize}

De esta manera, dependiendo el estado en el que se encuentre, cambiará la forma en la que se distribuirá la demanda de energía. Esto puede verse en como se encuentra definida la función de transición externa, que actualiza estos valores. 

Como en esta caso las transiciones de estados suceden como respuesta a un evento externo, la función $\Delta_{int}$ no realiza otra función que \textbf{pasivar} al modelo, dejándolo a la espera del siguiente evento.

\begin{figure}
    \centering\includegraphics[width=0.7\textwidth]{secciones/figs/estadosContolador.pdf}
    \caption{Máquina de estados finita que describe la transición de estados en el controlador.}
\end{figure}


\deltaInt{
    \STATE passivate()
}

% TODO: Update all function below
\deltaExt{
    \IF {x.port = batteryStatePort}
        \STATE S' $\leftarrow$ $<$ x.value, currentLoadDemand, batteryDemand, gridDemand $>$
        \STATE S'' $\leftarrow$ updateGridConsuption(S')
    \ELSIF {x.port = loadDemand}
        \STATE S' $\leftarrow$ $<$ batteryState, x.value, currentLoadDemand, batteryDemand, gridDemand $>$
        \STATE S'' $\leftarrow$ updateGridConsuption(S')
    \ELSIF {x.port = batterySurplusEnergy}
        \STATE S'' $\leftarrow$ $<$ batteryState, currentLoadDemand, LoadDemand, batteryDemand, -x.value $>$
    \ENDIF
    \STATE nextChange = 0
    \RETURN S''
}

\begin{algorithm}
    \caption{$UpdateGridConsuption(S)$}
    \begin{algorithmic}[H]
        \IF {S.batteryState == AVAILABE or S.batteryState == FULL}
            \IF {S.currentLoadDemand $<$ MAX\_CHARGE}
                \RETURN $<$batteryState, currentLoadDemand, currentLoadDemand, 0$>$
            \ELSE
                \RETURN $<$batteryState, currentLoadDemand, MAX\_CHARGE, currentLoadDemand-MAX\_CHARGE$>$
            \ENDIF
        \ELSE
            \RETURN $<$batteryState, currentLoadDemand, 0, currentLoadDemand$>$
        \ENDIF
    \end{algorithmic}
\end{algorithm}

\lambdaOut{
    \STATE sendOutput(time, gridDemandPort, S.gridDemand)
    \STATE sendOutput(time, batteryDemandPort, S.batteryDemand)
}

\subsubsection{Carga}
\subsubsection{Red Eléctrica}

\subsection{Modelos Acoplados}

\subsubsection{Casa}
\subsubsection{Top Model}