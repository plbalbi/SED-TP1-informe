% Document-wide defines
\newcommand{\Reals}{{\rm I\!R}}

% DEVS model definition helpers
\newcommand{\deltaInt}[1]{
    \begin{algorithm}[H]
        \caption{$\delta_{int} (s)$}
        \begin{algorithmic}
        #1
        \end{algorithmic}
    \end{algorithm}
}
\newcommand{\deltaExt}[1]{
    \begin{algorithm}[H]
        \caption{$\delta_{ext} (s,e,x)$}
        \begin{algorithmic}
        #1
        \end{algorithmic}
    \end{algorithm}
}
\newcommand{\lambdaOut}[1]{
    \begin{algorithm}[H]
        \caption{$\lambda (s)$}
        \begin{algorithmic}
        #1
        \end{algorithmic}
    \end{algorithm}
}

\section{Especificación Formal}

\subsection{Modelos Atómicos}

\subsubsection{Panel solar y generador eólico}
Como fue descripto en el modelo conceptual (\ref{section:modeloConceptual}),
el modelo que representa al panel solar, y también al generador eólico son
simples. Ambos tendrán un puerto de entrada, el cual recibirá el valor de la
magnitud de clima que los afecta, siendo radiación en el caso del primero, y
la velocidad del viento para el segundo. Por otro lado, tendrán un puerto de
salida, por el cual notificarán a los modelos que tengan una conexión al
mismo, cual es la nueva cantidad de energía que están produciendo.

% TODO: Poner algo haciendo referencia a que DEVS puede manejar eventos (cambios en dichas magnitudes climáticas) a distintas frecuencias de ocurrencia. Leer en el Wainer como se explicaba esto.
% TODO: Poner las funciones de transición, y las funciones matemáticas con las cuales se calculará la potencia producida.

$Generador = <X,Y,S,\delta_{int}, \delta_{ext}, \lambda, ta>$

Definiendo cada elemento de la tupla DEVS como:

\begin{align*}
X &= \Reals_{\geq0} & Y &= \Reals_{\geq0} & S &= energiaProducida \in \Reals_{\geq 0} \\
\end{align*}

\deltaInt{
    \STATE passivate()
}

\deltaExt{
    \STATE $energiaProducida \leftarrow calcularPotenciaProducida(x.value) $
}

\lambdaOut{
    \STATE sendOutput(time, out, energiaProducida)
}

\subsubsection{Batería}
El modelo de la bater\'ia consta de tres puertos de entrada y dos de salida.

Tiene un puerto en el cual recibe los cambios en la cantidad de energ\'ia generada
por el generador eólico y otro en el cual recibe la generada por el panel solar.
En el tercer puerto recibe la cantidad de energía solicitada por el controlador.

Los puertos de salida son el del estado de la batería, que informa un evento, 
que puede ser \emph{Vacía}, \emph{Disponible} y \emph{Completa}.

\begin{itemize}
    \item \emph{Vacía}: Este evento ocurre cuando la carga de la batería llega a 0. 
    A partir de este momento, la batería no envía más energía al controlador, hasta
    que la carga alcance el mínimo.
    \item \emph{Disponibe}: Este evento se produce cuando la batería, una vez
    descargada, vuelve a alcanzar el nivel mínimo de carga. A partir de este
    momento, el controlador puede volver a solicitar carga a la batería.
    \item \emph{Completa}: Ocurre cuando la carga alcanza la máxima capacidad.
\end{itemize}

El otro puerto es por donde envía el sobrante de energía. El sobrante es la
diferencia entre lo producido y lo solicitado, cuando la batería se encuentra
llena. 

El estado actual de la batería se determina por la cantidad de energía enviada
por los generadores, la solicitada por el controlador, el nível de carga actual
de la batería y la ultima vez que se actualizó el nivel de la bateria.

$$S = \mathbb{R}_{\geq 0} \times \mathbb{R}_{\geq 0} \times \mathbb{R}_{\geq 0} \times \{x \in \mathbb{R} | 0 \leq x \leq maxima\_carga \} \times \mathbb{R}_{\geq 0}$$

Este último valor se usa para evitar tener que actualizar el nivel de carga
de manera continual en intervalos pequeños de tiempo: El nivel real de la carga de
la batería en un momento de tiempo $t$ es igual a \\
$$CargaReal = Carga+(UltimaActualizacion - t)\times(EnergiaProducida - EnergiaConsumiendose)$$

Esta misma formula se puede reescribir para calcular el próximo evento a suceder,
y resulta ser:
$$ta = \frac{CargaEnEvento - Carga}{EnergiaProducida - EnergiaConsumiendose}$$

\deltaExt{
    \STATE {charge $\leftarrow$ calculate\_current\_charge(s, e)}
    \IF {x.port = SOLAR\_PANEL}
        \STATE S' $\leftarrow$ $<$x.value, S.eolic\_energy, S.sending\_energy, charge, e$>$
    \ELSIF{x.port = EOLIC\_TURBINE}
        \STATE S' $\leftarrow$ $<$S.solar\_energy, x.value, S.sending\_energy, charge, e$>$
    \ELSIF{x.port = REQUIRED\_ENERGY}
        \IF {isAvailable(S)}
            \STATE sending\_energy $\leftarrow$ x.value
        \ELSE
            \STATE sending\_energy $\leftarrow$ 0
        \ENDIF
        \STATE S' $\leftarrow$ $<$S.solar\_energy, S.eolic\_energy, sending\_energy, charge, e$>$
    \ENDIF
    \STATE next\_change $\leftarrow$ calculate\_next\_event(S')
    \RETURN {S'}
}

\lambdaOut{
    \IF {S.charge = 0}
        \STATE sendOutput(time, battery\_state, EMPTY)
    \ELSIF {S.charge = MIN\_CAPACITY}
        \STATE sendOutput(time, battery\_state, AVAILABE)
    \ELSIF {S.charge = BATTERY\_CAPACITY}
        \STATE sendOutput(time, battery\_state, FULL)
        \STATE sendOutput(time, surplus\_energy, S.energiaProducida - S.energiaConsumiendose)
    \ENDIF
}

Durante las transiciones externas, o bien la energía producida o la energia consumida
cambian de valor, así que primero se actualizan el valor actual de la carga (como se mensiona antes),
y despues actualizamos los valores de la energía consumiendose/producientdo, salvo en el caso de 
de la energía solicitada, cuando la batería no esté disponible, en cuyo caso, se seguirá manteniendo en 0.
Finalimente calculamos cual va a ser el próximo evento que va a ocurrír en función de la
carga actual y de la diferencia entre la energía producida y la consumida.

Las transiciones internas ocurren durante los eventos mensionados anteriormente. En ellas,
volvemos a actualizar el valor de la carga y calculamos cuando va a suceder el proximo evento 

Las transiciones externas se producen cuando se envían valores a través de los puertos
de entrada. 

\subsubsection{Controlador}

El modelo del controlador consta de cinco puertos, tres de entrada y dos de salida.

Uno de los puertos de entrada es donde recibe las solicitudes de la carga, otro
es donde recibe el estado actual de la batería y el tercero es por donde la batería 
le avisa la cantidad de energía sobrante.

En cuanto a los puertos de salida, uno de ellos se corresponde a los pedidos (o venta) de 
energía que hace a la red y el otro a la batería.

En cuanto al estado interno del controlador, el mismo debe almacenar los siguientes valores:

\begin{itemize}
    \item \textbf{batteryState:} Almacena el estado actual de la bateria que tiene conectada,
    es necesario para determinar si podemos pedirle energía a la misma o no.
    \item \textbf{currentLoadDemand:} Cantidad de energía solicitada por la carga.
    \item \textbf{batteryDemand:} Cantidad de energía solicitada/vendida a la batería.
    \item \textbf{gridDemand:} Cantidad de energía solicitada a la red.
\end{itemize}

El modelo actual tiene el siguiente comportamiento: Si la batería esta disponible, le solicitará
toda la carga necesaria para cubrir las necesidades de la carga, siempre que esta no supere
el umbral definido, en cuyo caso le pedirá el máximo posible y lo demás lo pedirá de la red.
Si la bateria está descargada, esta dejará de suministrarle energía hasta que no se encuentre
disponible nuevamente.

En el caso de que la batería le informe que tiene un excedente de producción, el controlador
lo enviará a la red. Esto se representa con un valor negativo.

\deltaInt{
    \STATE passivate()
}

\deltaExt{
    \IF {x.port = batteryStatePort}
        \STATE S' $\leftarrow$ $<$ x.value, currentLoadDemand, batteryDemand, gridDemand $>$
        \STATE S'' $\leftarrow$ updateGridConsuption(S')
    \ELSIF {x.port = loadDemand}
        \STATE S' $\leftarrow$ $<$ batteryState, x.value, currentLoadDemand, batteryDemand, gridDemand $>$
        \STATE S'' $\leftarrow$ updateGridConsuption(S')
    \ELSIF {x.port = batterySurplusEnergy}
        \STATE S'' $\leftarrow$ $<$ batteryState, currentLoadDemand, LoadDemand, batteryDemand, -x.value $>$
    \ENDIF
    \STATE nextChange = 0
    \RETURN S''
}

\begin{algorithm}
    \caption{$UpdateGridConsuption(S)$}
    \begin{algorithmic}[H]
        \IF {S.batteryState == AVAILABE or S.batteryState == FULL}
            \IF {S.currentLoadDemand $<$ MAX\_CHARGE}
                \RETURN $<$batteryState, currentLoadDemand, currentLoadDemand, 0$>$
            \ELSE
                \RETURN $<$batteryState, currentLoadDemand, MAX\_CHARGE, currentLoadDemand-MAX\_CHARGE$>$
            \ENDIF
        \ELSE
            \RETURN $<$batteryState, currentLoadDemand, 0, currentLoadDemand$>$
        \ENDIF
    \end{algorithmic}
\end{algorithm}

\lambdaOut{
    \STATE sendOutput(time, gridDemandPort, S.gridDemand)
    \STATE sendOutput(time, batteryDemandPort, S.batteryDemand)
}

\subsubsection{Carga}
\subsubsection{Red Eléctrica}

\subsection{Modelos Acoplados}

\subsubsection{Casa}
\subsubsection{Top Model}